---
title: Coin Management
draft: true
---

A key concept when programming on Sui is that of owned objects. Address-owned objects are important in that they allow for highly parallelizable transactions. And they also logically map to assets or resources that someone exclusively owns. Coins are a typical case of owned objects usage, with cash being a real-life reference. The owned objects paradigm, however, and particularly as related to coins, is somewhat of a divergence from other blockchains which have a concept of balance. In other words, in other systems, especially account based systems, coins are held in a single location (field) which can be thought of as a balance in a bank account.
Because of that, in Sui, it is very common for a user to own a number of coins, at times even a significant number of them. And there may be a desire to merge some or all of those coins into a single one in some scenarios. At times merging coins together is also vital in that the amount required or desired to execute a transaction is more than any single coin owned by the user, thus making merging an inevitable step.

## SDK Usage 
Sui SDK manages coins on user behalf and, as such, removes the onerous of having to deal with coin management. The SDK attempts to merge coins as much as possible and it assumes that transactions are executed in sequence. That assumption is very reasonable with a usage that is wallet based and, in general, for common scenarios. We recommend relying on that feature if users do not have a need for heavy parallel or concurrent execution.

## Gas Smashing
When executing a transaction Sui allows a number of coins to be provided as payment. In other words, the payment can be a vector of coins rather than a single coin. That feature, known as gas smashing, performs merging of coins automatically, and presents the Programmable Transaction Block writer with a single gas coin that can be used for other purposes besides just gas. 
Basically, a user can provide as many coins as desired (with a max limit defined in the protocol configuration) and have all of them merged (smashed) into the first coin provided as payment. That coin, minus the gas budget, is then available inside the transaction and can be used in any command. If the coin is unused it is returned to the user.
Gas smashing is a key feature - and a key concept to understand - for users to have an easy and seamless management of coins.

## Generic Coins
Gas smashing works well for Coin<Sui> which is the only coin type that can be used for gas payment.
Any other coin type requires explicit management from users. Programmable transactions offer a mergeCoins command that can be used to combine multiple coins into a single one. And a splitCoins as the complementary operation.
From a cost perspective, those are very cheap transactions, however they require a user to be aware of their coin distribution and their own needs.

## Concurrency
Merging coins, and particularly Coin<Sui>, into a single coin or a very small number of coins may prove problematic in scenarios where heavy or high concurrency is required.
If a user merges all Coin<Sui> into a single one, every transaction would have to be sequentially submitted. The coin - being an owned object - would have to be provided with a version and it would be locked by the system when signing a transaction, effectively making it impossible to use it in any other transaction until the one that locked it was executed. Moreover an attempt to sign multiple transactions with the same coin may result in equivocation and the coin being unusable and locked until the end of the epoch.
So when heavy concurrency is required a user should first split a coin into as many coins as the number of transactions to execute concurrently. Alternatively multiple and different coins (gas smashing) would have to be provided to the different transactions.
It is critically important that the set of coins used in the different transactions has no intersection at all. No coin should be used in multiple transactions. Users must understand that concept and act accordingly.
It may be worth to point out that there are several pitfalls in dealing with heavy concurrency. Concurrency in transaction execution is not the only performance bottleneck. In creating and submitting a transaction several round trips with a server (full node) may be required to discover and fetch the right objects, and to dry run a transaction. Those round trips may affect performance significantly. 
Concurrency is a very difficult subject and it is beyond the scope of this documentation. Please understand that maximum care has to be used when dealing with coin management in the face of concurrency, and the right strategy is often tied to the specific scenario, rather than universally available. 
