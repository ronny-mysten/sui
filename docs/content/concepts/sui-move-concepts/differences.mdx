---
title: Differences Between Sui Move and Diem Move
sidebar_label: Differences in Sui Move
---

The Sui Move programming model is based off the core (previously Diem) Move language but contains some important differences. Sui takes advantage of Move's security and flexibility and enhances it with the features described in the following sections to vastly improve throughput, reduce delays in finality, and make Move programming easier. For full details, see the [Sui Smart Contracts Platform](https://github.com/MystenLabs/sui/blob/main/doc/paper/sui.pdf) white paper.

::: tip

The Sui documentation often references Sui Move as simply Move. Where relevant, the documentation expressly refers to the base language as "core Move".

:::

In general, core Move code written for other systems works in Sui with these exceptions:

    - [Global storage operators](https://move-language.github.io/move/global-storage-operators.html)
    - [Key abilities](https://github.com/move-language/move/blob/main/language/documentation/book/src/abilities.mdx)

## Key differences

Key differences between core and Sui Move include:
    
    - Sui uses its own [object-centric global storage](#global-storage)
    - Addresses represent [Object IDs](#object-ids)
    - Sui objects have [globally unique IDs](#global-unique)
    - Sui has [module initializers](#module-initializers) (init)
    - Sui [entry points](#entry-points) take object references as input

### Object-centric global storage {#global-storage}

In core Move, global storage is part of the programming model that you can access through special operations, such as `move_to`, `move_from`, and more global storage operators. Core Move stores both resources and modules in global storage. When you publish a module, it's stored into a newly generated module address inside Move. When you create a new object (resource), it's usually stored into some address, as well. This approach creates a problem, however, as on-chain storage is expensive and limited (not optimized for storage and indexing). Current blockchains cannot scale effectively to handle storage-heavy applications, such as marketplaces and social apps.

Sui Move addresses the scaling issue by not having global storage. Consequently, Sui Move doesn't allow any of the global storage-related operations (there is a bytecode verifier to detect violations for this). Instead, storage happens exclusively within Sui. When you publish a module, the newly published module is stored in Sui storage, instead of Move storage. Similarly, newly created objects are stored in Sui storage.

:::info

When you need to read an object in Move, you cannot rely on global storage operations. Instead, Sui must explicitly pass all objects that you need to access into Move.

:::

### Addresses represent Object IDs {#object-ids}

In Move, there is a special address type. This type is used to represent addresses in core Move. Core Move needs to know the address of an account when dealing with the global storage. The address type is 16 bytes, which is sufficient for the core Move security model.

In Sui, because it doesn't support global storage in core Move, the address type is repurposed to represent a unique, 32-byte ID of either an object or an account. You can access the address of the sender of a transaction from the transaction context. Object IDs also have their address values wrapped in the structs `ID` and `UID`.  Refer to the [object.move](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/sui-framework/sources/object.move) file in Sui framework for an understanding of address use. 

### Object with key ability, globally unique IDs {#global-unique}

In core Move, the `key` ability is used to tell that the type can be used as a key for global storage. In Sui, this ability has been repurposed to declare a struct as an object. Objects owned by an account are passed in as arguments to transactions, and other objects (using the dynamic fields API dynamic_fields.move) can be accessed dynamically during the transaction. Sui requires that any struct with key ability must start with an id field with the UID type. The UID type contains both the ObjectID. Other metadata (such as the sequence number) is managed by the Sui Network outside of Move. . Sui has a bytecode verifier in place to make sure that the UID field cannot be transferred to other objects (the IDs of objects cannot be re-used once the object is destructured).

### Module initializers {#module-initializers}

As described in [Object-centric global storage](#global-storage), you publish Sui Move modules into Sui storage. The Sui runtime executes a special [initializer function](init.mdx) you optionally define in a module only once at the time of module publication to pre-initialize module-specific data (for example, creating singleton objects).

### Entry points take object references as input {#entry-points}

You can call public functions from Sui transactions (called programmable transaction blocks). These functions can take objects by value, by immutable reference, or by mutable reference. If taken by value, you can destroy the object, wrap it (in another object), or transfer it (to a Sui ID specified by an address). If taken by mutable reference, the modified version of the object saves to storage without any change in ownership. In any case, the Sui network authenticates the object and declares it's usage as a part of the transaction. 

In addition to calling public functions, you can call a function that is marked `entry` even if it is private. As long as other public functions have not used it's inputs. 

